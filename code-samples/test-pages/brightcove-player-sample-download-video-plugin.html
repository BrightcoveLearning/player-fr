<style>
  /* * Le style du corps est juste pour la * couleur d'arrière-plan du codepen. * Ne pas inclure dans votre code. */ corps { background-color: #111; color: #fff; } /* * Les styles essentiels à l'échantillon * sont ci-dessous */ .video-js { height: 344px; width: 610px; } .downloadStyle { order: 9; -webkit-box-ordinal-group: 9; -moz-box-ordinal-group: 9; -webkit-order: 9; -ms-flex-order: 9; padding-top: 7px !important; }




</style>

  <video-js id="myPlayerID"
  data-video-id="5701190170001"
  data-account="1752604059001"
  data-player="S10RYv9QG"
  data-embed="default"
  data-application-id
  class="video-js"
  controls></video-js>

<script src="https://players.brightcove.net/1752604059001/S10RYv9QG_default/index.min.js"></script>

<script>
  videojs.getPlayer('myPlayerID').ready(function() { // Create variables and new div, anchor and image for download icon var myPlayer = this, videoName, totalRenditions, mp4Ara = [], highestQuality, spacer, newElement = document.createElement("div"), newImage = document.createElement("img"); myPlayer.on("loadstart", function() { //Reinitialize array of MP4 renditions in case used with playlist //This prevents the array having a cumulative list for all videos in playlist mp4Ara = []; // +++ Get video name and the MP4 renditions +++ videoName = myPlayer.mediainfo["name"]; videoName = removeSpaces(videoName); rendtionsAra = myPlayer.mediainfo.sources; console.table(rendtionsAra) totalRenditions = rendtionsAra.length; // +++ Loop over videos and extract only MP4 versions +++ for (var i = 0; i &lt; totalRenditions; i++) { if ( rendtionsAra[i].container === "MP4" &amp;&amp; rendtionsAra[i].hasOwnProperty("src") ) { mp4Ara.push(rendtionsAra[i]); } } // +++ Trier les rendus du plus haut au plus bas sur la taille+++ mp4Ara.sort(function(a, b) { return b.size - a.size; }); console.table(mp4Ara) // +++ Extraire le rendu le plus élevé +++ highQuality = mp4Ara[0].src; // +++ Construire l'élément d'image de téléchargement +++ newElement.id = "downloadImage"; newElement.className = "vjs-control downloadStyle"; newImage.setAttribute( "src", "https://solutions.brightcove.com/bcls/brightcove-player/download-video/file-download.png" ); newImage.style["cursor"] = "pointeur"; // +++ Sur un clic sur l'image, appelez la fonction de téléchargement +++ newImage.onclick = function() { // The download function forces download by the browsers // NOT opening the video in a new window/tab var x=new XMLHttpRequest(); x.open("GET", highestQuality, true); x.responseType = 'blob'; x.onload=function(e){download(x.response, videoName, "video/mp4"); } x.send(); // }; newElement.appendChild(newImage); // +++ Placer l'image de téléchargement +++ // Obtenir un handle sur l'élément spacer spacer = myPlayer.controlBar.customControlSpacer.el(); // Définit le contenu de l'espacement pour qu'il soit justifié à droite spacer.setAttribute("style", "justify-content: flex-end;"); // Place le nouvel élément dans l'espaceur spacer.appendChild(newElement); }); }); /* * supprime les espaces d'une chaîne * @param {String} chaîne str à traiter * @return {String} chaîne coupée */ fonction removeSpaces(str) { // remove spaces and periods str = str.replace(/\s/g, ''); str = str.replaceAll('.', ''); return str; } //download.js v4.2, par dandavis; 2008-2016. [CCBY2] voir http://danml.com/download.html pour les tests/utilisation // v1 a débarqué un moyen compatible FF + Chrome de télécharger des chaînes dans des fichiers locaux sans nom, mis à niveau pour utiliser un cadre caché et un mime facultatif // La v2 a ajouté des fichiers nommés via un [téléchargement], la prise en charge de msSaveBlob, IE (10+) et la prise en charge de window.URL pour des sauvegardes plus importantes et plus rapides que les dataURLs // v3 a ajouté dataURL et Blob Input, l'arité de basculement de liaison et la sauvegarde des URL de données héritées a été amélioré avec le mime de téléchargement forcé et la prise en charge de base64. 3.1 Amélioration de la gestion du safari.//v4 ajoute AMD/UMD, CommonJS et simple prise en charge du navigateur//v4.1 ajoute la capacité de téléchargement d'URL via un argument URL solo (même domaine/CORS uniquement)//v4.2 ajoute des noms de variables sémantiques, une prise en charge de données longue (plus de 2 Mo) et des ancres temporaires masquées par défaut//https://github.com/rndme/download ( fonction (racine, usine) { if (typeof define === "function" &amp;&amp; define.amd) { // AMD. Register as an anonymous module. define([], factory); } sinon si (type d'exportations === « objet ») { // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(); } sinon { // Browser globals (root is window) root.download = factory(); }}) (ceci, function () { return function download(data, strFileName, strMimeType) { var self = window, // this script is only for browsers anyway... defaultMime = "application/octet-stream", // this default mime also triggers iframe downloads mimeType = strMimeType || defaultMime, payload = data, url = !strFileName &amp;&amp; !strMimeType &amp;&amp; payload, anchor = document.createElement("a"), toString = function(a) { return String(a); }, myBLOB = Self.BLOB || Self.MozBlob || Self.WebKitBlob || ToString, FileName = StrFileName || &amp; « télécharger », blob, lecteur ; MyBLOB = MyBlob.Call ? MyBlob.Bind (self) : Blob ; if (String (this) === « true ») { //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback payload = [payload, mimeType]; mimeType = payload[0]; payload = payload[1]; } if (url &amp;&amp; url.length &lt; 2048) { // if no filename and no mime, assume a url was passed as the only argument fileName = url .split("/") .pop() .split("?")[0]; anchor.href = url; // assign href prop to temp anchor if (anchor.href.indexOf(url) !== -1) { // if the browser determines that it's a potentially valid url path: var ajax = new XMLHttpRequest(); ajax.open("GET", url, true); ajax.responseType = "blob"; ajax.onload = function(e) { download(e.target.response, fileName, defaultMime); } ; setTimeout (function () { ajax.send(); }, 0) ;//permet de définir des en-têtes Ajax personnalisés à l'aide du retour : retour ajax ; }//se termine si l'URL est valide ? }//Fin si URL ? //allez-y et téléchargez les DataURL tout de suite si (/^data \ : [\ w+ \ -] + \/[\ w+ \ -] + [, ;] /.test (charge utile)) { if (payload.length &gt; 1024 * 1024 * 1.999 &amp;&amp; myBlob !== toString) { payload = dataUrlToBlob(payload); mimeType = payload.type || defaultMime; } { return navigator.msSaveBlob // IE10 can't do a[download], only Blobs: ? navigator.msSaveBlob(dataUrlToBlob(payload), fileName) : saver(payload); // everyone else can save dataURLs un-processed }} //se termine si DataURL est passé ? blob = instance de charge utile de mon BLOB ? payload : nouveau MyBlob ([charge utile], { type: mimeType }) ; fonction DaturlToBlob (StrURL) { var parts = strUrl.split(/[:;,]/), type = parts[1], decoder = parts[2] == "base64" ? atob : decodeURIComponent, binData = decoder(parts.pop()), mx = binData.length, i = 0, uiArr = new Uint8Array(mx); for (i; i &lt; mx; ++i) uiArr[i] = binData.charCodeAt(i); return new myBlob([uiArr], { type: type }) ;} économiseur de fonction (url, WinMode) { if ("download" in anchor) { //html5 A[download] anchor.href = url; anchor.setAttribute("download", fileName); anchor.className = "download-js-link"; anchor.innerHTML = "downloading..."; anchor.style.display = "none"; document.body.appendChild(anchor); setTimeout(function() { anchor.click(); document.body.removeChild(anchor); if (winMode === true) { setTimeout(function() { self.URL.revokeObjectURL(anchor.href); }, 250) ;}}, 66) ; retourne true ;}//gérer le safari non [télécharger] du mieux que nous pouvons : si (/(Version) \/(\ d+) \. (\ d+) (? : \. (\ d+)) ?. *Safari \ //.test (Navigator.UserAgent)) { url = url.replace(/^data:([\w\/\-\+]+)/, defaultMime); if (!window.open(url)) { // popup blocked, offer direct download: if ( confirm( "Displaying New Document\n\nUse Save As... to download, then click back to return to this page." ) ) { location.href = url; }} renvoie vrai ;} //dois-je télécharger iframe DateURL (ancien ch+FF) : var f = Document.CreateElement (« iframe ») ; Document.Body.AppendChild (f) ; if (! WinMode) { // force a mime that will download: url = "data:" + url.replace(/^data:([\w\/\-\+]+)/, defaultMime); } f.src = url ; setTimeout (function () { document.body.removeChild(f); }, 333) ;} //end saver si (Navigator.mssaveBlob) { // IE10+ : (has Blob, but not a[download] or URL) return navigator.msSaveBlob(blob, fileName); } si (self.url) { // simple fast and modern way using Blob and URL: saver(self.URL.createObjectURL(blob), true); } sinon { // handle non-Blob()+non-URL browsers: if (typeof blob === "string" || blob.constructor === toString) { try { return saver("data:" + mimeType + ";base64," + self.btoa(blob)); } attraper (y) { return saver("data:" + mimeType + "," + encodeURIComponent(blob)); }}//Blob mais pas prise en charge des URL : reader = new FileReader () ; reader.onload = function (e) { saver(this.result); } ; Reader.readasDateURL (blob) ;} return true ;} ; /* end download () */}) ;




</script>